import cv2
import numpy as np
from matplotlib import pyplot as plt
import math
import random




im = cv2.imread('../images/NO/190828_132418_0000547436_CAM2_NG_NO.bmp', cv2.IMREAD_GRAYSCALE)
im_orig = cv2.imread('../images/NO/190828_132418_0000547436_CAM2_NG_NO.bmp')

print(im.shape)

class Wire:   
            img = np.zeros([1200,1600], dtype="uint8")
            resized = np.zeros([600,800], dtype="uint8")
            x_locations = []
            top = -1
            bottom = -1
            def __init__(self, img):
                self.img = img  
                # choosing 10 x points randomly to feed the algorithm
                j = 0
                for i in range(img.shape[1]):
                    j = j+1
                    if j == 10:
                        break
                    r = random.SystemRandom()
                    number = r.randint(0,img.shape[1]) 
                    if number not in self.x_locations :
                        self.x_locations.append(i)
                self.resize_pic()        
                self.top = self.wire_frame(0) 
                self.bottom = self.wire_frame(1) 
        
            # A function to determine which y position is the most popular among final points y positions        
            def most_frequent(self,List): 
                counter = 0
                num = List[0] 
                for i in List: 
                    curr_frequency = List.count(i) 
                    if(curr_frequency> counter): 
                        counter = curr_frequency 
                        num = i 
                return num 
            

            def find_mean(self,x):
                mysum = 0
                points_y = []
                
                # we devide picture to 3 zones
                size = math.floor(self.resized.shape[0]/3)
                start = 0
                end = size
                for i in range(2):
                    for j in range(10):
                        r = random.SystemRandom()
                        number = r.randint(start,end) 
                        if number not in points_y:
                            points_y.append(number)
                    start = start + size
                    end = end + size
                
                for j in range(len(points_y)):
                    y = points_y[j]
                    pixel_value = self.resized[y,x]
                    mysum = mysum + pixel_value
                
                mean = np.mean(mysum/len(points_y))
                return mean
            
            def resize_pic(self):
                scale_percent = 50 # percent of original size
                width = int(self.img.shape[1] * scale_percent / 100)
                height = int(self.img.shape[0] * scale_percent / 100)
                dim = (width, height)
                resized = cv2.resize(self.img, dim, interpolation = cv2.INTER_AREA)
                self.resized = resized
                
            
            def wire_frame(self,arg):
                    y_values = []
                    # traversing the image with chosen x points, and checking pixel value against
                    #threshold = mean_value
                    # based on arg, start from 0:top or 1:bottom of the image 
                    if (arg == 0):
                         for i in self.x_locations:
                            mean_value = self.find_mean(i)
                            for j in range(self.resized.shape[0]):
                                pixel_value = self.resized[j,i]
                                if pixel_value > mean_value: 
                                    y_values.append(j)
                                    break;
                    
                    else:
                        for i in self.x_locations:
                            mean_value = self.find_mean(i)
                            for j in  reversed(range(self.resized.shape[0])):
                                pixel_value = self.resized[j,i]
                                if pixel_value > mean_value:
                                    y_values.append(j)
                                    break;

                    # final y position is the estimation of y by the algorithm
                    # * 2 because we scaled down the image before
                    found_y_position = self.most_frequent(y_values)
                    # * 2 because we scaled down the image before
                    found_y_position = found_y_position * 2
                    return found_y_position
    

# This function returns an object of Test 
def func(image): 
    return Wire(image) 

wire_obj = func(im)
top_position = wire_obj.top
bottom_position = wire_obj.bottom

lineThickness = 6
cv2.line(im_orig, (0, top_position), (1599, top_position), (0,0,255), lineThickness)
cv2.line(im_orig, (0, bottom_position), (1599, bottom_position), (0,0,255), lineThickness)
plt.imshow(im_orig,cmap = 'gray')

cv2.imwrite("result_f.bmp", im_orig) 

